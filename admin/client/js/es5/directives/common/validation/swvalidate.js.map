{"version":3,"names":[],"mappings":"","sources":["directives/common/validation/swvalidate.js"],"sourcesContent":["/**\n * This validate directive will look at the current element, figure out the context (save, edit, delete) and\n * validate based on that context as defined in the validation properties object.\n */\n'use strict';\nangular.module('slatwalladmin').directive('swValidate', ['$log', '$slatwall', function ($log, $slatwall) {\n    return {\n        restrict: \"A\",\n        require: '^ngModel',\n        link: function (scope, elem, attr, ngModel) {\n            //Define our contexts and validation property enums.\n            var ContextsEnum = {\n                SAVE: { name: \"save\", value: 0 },\n                DELETE: { name: \"delete\", value: 1 },\n                EDIT: { name: \"edit\", value: 2 }\n            };\n            var ValidationPropertiesEnum = {\n                REGEX: { name: \"regex\", value: 0 },\n                MIN_VALUE: { name: \"minValue\", value: 1 },\n                MAX_VALUE: { name: \"maxValue\", value: 2 },\n                EQ: { name: \"eq\", value: 3 },\n                NEQ: { name: \"neq\", value: 4 },\n                UNIQUE: { name: \"unique\", value: 5 },\n                LTE: { name: \"lte\", value: 6 },\n                GTE: { name: \"gte\", value: 7 },\n                MIN_LENGTH: { name: \"minLength\", value: 8 },\n                MAX_LENGTH: { name: \"maxLength\", value: 9 },\n                DATA_TYPE: { name: \"dataType\", value: 10 },\n                REQUIRED: { name: \"required\", value: 11 }\n            };\n            scope.validationPropertiesEnum = ValidationPropertiesEnum;\n            scope.contextsEnum = ContextsEnum;\n            var myCurrentContext = scope.contextsEnum.SAVE; //We are only checking the save context right now.\n            var contextNamesArray = getNamesFromObject(ContextsEnum); //Convert for higher order functions.\n            var validationPropertiesArray = getNamesFromObject(ValidationPropertiesEnum); //Convert for higher order functions.\n            var validationObject = scope.propertyDisplay.object.validations.properties; //Get the scope validation object.\n            var errors = scope.propertyDisplay.errors;\n            var errorMessages = [];\n            var failFlag = 0;\n            /**\n             * Iterates over the validation object looking for the current elements validations, maps that to a validation function list\n             * and calls those validate functions. When a validation fails, an error is set, the elements border turns red.\n             */\n            function validate(name, context, elementValue) {\n                var validationResults = {};\n                validationResults = { \"name\": \"name\", \"context\": \"context\", \"required\": \"required\", \"error\": \"none\", \"errorkey\": \"none\" };\n                for (var key in validationObject) {\n                    // Look for the current attribute in the\n                    // validation parameters.\n                    if (key === name || key === name + \"Flag\") {\n                        for (var inner in validationObject[key]) {\n                            var required = validationObject[key][inner].required || \"false\"; // Get\n                            // the\n                            // required\n                            // value\n                            var context = validationObject[key][inner].contexts || \"none\"; // Get\n                            // the\n                            // element\n                            // context\n                            //Setup the validation results object to pass back to caller.\n                            validationResults = { \"name\": key, \"context\": context, \"required\": required, \"error\": \"none\", \"errorkey\": \"none\" };\n                            var elementValidationArr = map(checkHasValidationType, validationPropertiesArray, validationObject[key][inner]);\n                            for (var i = 0; i < elementValidationArr.length; i++) {\n                                if (elementValidationArr[i] == true) {\n                                    if (validationPropertiesArray[i] === \"regex\" && elementValue !== \"\") {\n                                        //Get the regex string to match and send to validation function.\n                                        var re = validationObject[key][inner].regex;\n                                        var result = validate_RegExp(elementValue, re); //true if pattern match, fail otherwise.\n                                        if (result != true) {\n                                            errorMessages.push(\"Invalid input\");\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"REGEX\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        else {\n                                            errorMessages.push(\"Valid input\");\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"REGEX\"].name;\n                                            validationResults.fail = false;\n                                        }\n                                        return validationResults;\n                                    }\n                                    if (validationPropertiesArray[i] === \"minValue\") {\n                                        var validationMinValue = validationObject[key][inner].minValue;\n                                        $log.debug(validationMinValue);\n                                        var result = validate_MinValue(elementValue, validationMinValue);\n                                        $log.debug(\"e>v\" + result + \" :\" + elementValue, \":\" + validationMinValue);\n                                        if (result != true) {\n                                            errorMessages.push(\"Minimum value is: \" + validationMinValue);\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"MIN_VALUE\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        else {\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"MIN_VALUE\"].name;\n                                            validationResults.fail = false;\n                                        }\n                                        return validationResults;\n                                    }\n                                    if (validationPropertiesArray[i] === \"maxValue\") {\n                                        var validationMaxValue = validationObject[key][inner].maxValue;\n                                        var result = validate_MaxValue(elementValue, validationMaxValue);\n                                        $log.debug(\"Max Value result is: \" + result);\n                                        if (result != true) {\n                                            errorMessages.push(\"Maximum value is: \" + validationMaxValue);\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"MAX_VALUE\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        return validationResults;\n                                    }\n                                    if (validationPropertiesArray[i] === \"minLength\") {\n                                        var validationMinLength = validationObject[key][inner].minLength;\n                                        var result = validate_MinLength(elementValue, validationMinLength);\n                                        $log.debug(\"Min Length result is: \" + result);\n                                        if (result != true) {\n                                            errorMessages.push(\"Minimum length must be: \" + validationMinLength);\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"MIN_LENGTH\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        return validationResults;\n                                    }\n                                    if (validationPropertiesArray[i] === \"maxLength\") {\n                                        var validationMaxLength = validationObject[key][inner].maxLength;\n                                        var result = validate_MaxLength(elementValue, validationMaxLength);\n                                        $log.debug(\"Max Length result is: \" + result);\n                                        if (result != true) {\n                                            errorMessages.push(\"Maximum length is: \" + validationMaxLength);\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"MAX_LENGTH\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        return validationResults;\n                                    }\n                                    if (validationPropertiesArray[i] === \"eq\") {\n                                        var validationEq = validationObject[key][inner].eq;\n                                        var result = validate_Eq(elementValue, validationEq);\n                                        if (result != true) {\n                                            errorMessages.push(\"Must equal \" + validationEq);\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"EQ\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        return validationResults;\n                                    }\n                                    if (validationPropertiesArray[i] === \"neq\") {\n                                        var validationNeq = validationObject[key][inner].neq;\n                                        var result = validate_Neq(elementValue, validationNeq);\n                                        if (result != true) {\n                                            errorMessages.push(\"Must not equal: \" + validationNeq);\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"NEQ\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        return validationResults;\n                                    }\n                                    if (validationPropertiesArray[i] === \"lte\") {\n                                        var validationLte = validationObject[key][inner].lte;\n                                        var result = validate_Lte(elementValue, validationLte);\n                                        if (result != true) {\n                                            errorMessages.push(\"Must be less than \" + validationLte);\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"LTE\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        return validationResults;\n                                    }\n                                    if (validationPropertiesArray[i] === \"gte\") {\n                                        var validationGte = validationObject[key][inner].gte;\n                                        var result = validate_Gte(elementValue, validationGte);\n                                        if (result != true) {\n                                            errorMessages.push(\"Must be greater than: \" + validationGte);\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = \"invalid-\" + ValidationPropertiesEnum[\"GTE\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        return validationResults;\n                                    }\n                                    if (validationPropertiesArray[i] === \"required\") {\n                                        var validationRequire = validationObject[key][inner].require;\n                                        var result = validate_Required(elementValue, validationRequire);\n                                        if (result != true) {\n                                            errorMessages.push(\"Required\");\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = ValidationPropertiesEnum[\"REQUIRED\"].name;\n                                            validationResults.fail = true;\n                                        }\n                                        else {\n                                            errorMessages.push(\"Required\");\n                                            validationResults.error = errorMessages[errorMessages.length - 1];\n                                            validationResults.errorkey = ValidationPropertiesEnum[\"REQUIRED\"].name;\n                                            validationResults.fail = false;\n                                        }\n                                        return validationResults;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            /**\n             * Function to map if we need a validation on this element.\n             */\n            function checkHasValidationType(validationProp, validationType) {\n                if (validationProp[validationType] != undefined) {\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            /**\n             * Iterates over the properties object finding which types of validation are needed.\n             */\n            function map(func, array, obj) {\n                var result = [];\n                forEach(array, function (element) {\n                    result.push(func(obj, element));\n                });\n                return result;\n            }\n            /**\n             * Array iteration helper.\n             */\n            function forEach(array, action) {\n                for (var i = 0; i < array.length; i++)\n                    action(array[i]);\n            }\n            /**\n             * Helper function to read all the names in our enums into an array that the higher order functions can use.\n             */\n            function getNamesFromObject(obj) {\n                var result = [];\n                for (var i in obj) {\n                    var name = obj[i].name || \"stub\";\n                    result.push(name);\n                }\n                return result;\n            }\n            /**\n             * Tests the value for a RegExp match given by the pattern string.\n             * Validates true if pattern match, false otherwise.\n             */\n            function validate_RegExp(value, pattern) {\n                var regex = new RegExp(pattern);\n                if (regex.test(value)) {\n                    return true;\n                }\n                return false;\n            }\n            /**\n             * Validates true if userValue >= minValue (inclusive)\n             */\n            function validate_MinValue(userValue, minValue) {\n                return (userValue >= minValue);\n            }\n            /**\n             * Validates true if userValue <= maxValue (inclusive)\n             */\n            function validate_MaxValue(userValue, maxValue) {\n                return (userValue <= maxValue) ? true : false;\n            }\n            /**\n             * Validates true if length of the userValue >= minLength (inclusive)\n             */\n            function validate_MinLength(userValue, minLength) {\n                return (userValue.length >= minLength) ? true : false;\n            }\n            /**\n             * Validates true if length of the userValue <= maxLength (inclusive)\n             */\n            function validate_MaxLength(userValue, maxLength) {\n                return (userValue.length <= maxLength) ? true : false;\n            }\n            /**\n             * Validates true if the userValue == eqValue\n             */\n            function validate_Eq(userValue, eqValue) {\n                return (userValue == eqValue) ? true : false;\n            }\n            /**\n             * Validates true if the userValue != neqValue\n             */\n            function validate_Neq(userValue, neqValue) {\n                return (userValue != neqValue) ? true : false;\n            }\n            /**\n             * Validates true if the userValue < decisionValue (exclusive)\n             */\n            function validate_Lte(userValue, decisionValue) {\n                return (userValue < decisionValue) ? true : false;\n            }\n            /**\n             * Validates true if the userValue > decisionValue (exclusive)\n             */\n            function validate_Gte(userValue, decisionValue) {\n                return (userValue > decisionValue) ? true : false;\n            }\n            /**\n             * Validates true if the userValue === property\n             */\n            function validate_EqProperty(userValue, property) {\n                return (userValue === property) ? true : false;\n            }\n            /**\n             * Validates true if the given value is !NaN (Negate, Not a Number).\n             */\n            function validate_IsNumeric(value) {\n                return !isNaN(value) ? true : false;\n            }\n            /**\n             * Validates true if the given userValue is empty and the field is required.\n             */\n            function validate_Required(property, userValue) {\n                return (userValue == \"\" && property == true) ? true : false;\n            }\n            /**\n             * Handles the 'eager' validation on every key press.\n             */\n            ngModel.$parsers.unshift(function (value) {\n                var name = elem.context.name; //Get the element name for the validate function.\n                var currentValue = elem.val(); //Get the current element value to check validations against.\n                var val = validate(name, myCurrentContext, currentValue) || {};\n                //Check if field is required.\t\t\t\t\n                $log.debug(scope);\n                $log.debug(val);\n                ngModel.$setValidity(val.errorkey, !val.fail);\n                return true;\n            }); //<---end $parsers\n            /**\n             * This handles 'lazy' validation on blur.\n             */\n            elem.bind('blur', function (e) {\n            });\n        }\n    };\n}]);\n\n//# sourceMappingURL=../../../directives/common/validation/swvalidate.js.map"],"file":"directives/common/validation/swvalidate.js","sourceRoot":"/source/"}