{"version":3,"names":[],"mappings":"","sources":["directives/common/swsortable.js"],"sourcesContent":["'use strict';\nangular.module('slatwalladmin').directive(\"sw:sortable\", ['expression', 'compiledElement', function (expression, compiledElement) {\n    // add my:sortable-index to children so we know the index in the model\n    compiledElement.children().attr(\"sw:sortable-index\", \"{{$index}}\");\n    return function (linkElement) {\n        var scope = this;\n        linkElement.sortable({\n            placeholder: \"placeholder\",\n            opacity: 0.8,\n            axis: \"y\",\n            update: function (event, ui) {\n                // get model\n                var model = scope.$apply(expression);\n                // remember its length\n                var modelLength = model.length;\n                // rember html nodes\n                var items = [];\n                // loop through items in new order\n                linkElement.children().each(function (index) {\n                    var item = $(this);\n                    // get old item index\n                    var oldIndex = parseInt(item.attr(\"sw:sortable-index\"), 10);\n                    // add item to the end of model\n                    model.push(model[oldIndex]);\n                    if (item.attr(\"sw:sortable-index\")) {\n                        // items in original order to restore dom\n                        items[oldIndex] = item;\n                        // and remove item from dom\n                        item.detach();\n                    }\n                });\n                model.splice(0, modelLength);\n                // restore original dom order, so angular does not get confused\n                linkElement.append.apply(linkElement, items);\n                // notify angular of the change\n                scope.$digest();\n            }\n        });\n    };\n}]);\n\n//# sourceMappingURL=../../directives/common/swsortable.js.map"],"file":"directives/common/swsortable.js","sourceRoot":"/source/"}